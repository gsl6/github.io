<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ServletConfig</title>
    <link href="/2020/06/04/ServletConfig/"/>
    <url>/2020/06/04/ServletConfig/</url>
    
    <content type="html"><![CDATA[<h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><p>在运行servlet的时候，需要动态加载一些配置信息（设置编码格式），或者是设置配置的时候，就可以用ServletConfig来获取设置的信息，获取的只是当前servlet配置</p><p>步骤:</p><ul><li><p>.需要在web.xml里进行配置（以键值队的方式进行）</p><div class="hljs"><pre><code class="hljs livecodeserver">&lt;init-<span class="hljs-built_in">param</span>&gt;    &lt;<span class="hljs-built_in">param</span>-name&gt;encoding&lt;/<span class="hljs-built_in">param</span>-name&gt;    &lt;<span class="hljs-built_in">param</span>-<span class="hljs-built_in">value</span>&gt;GBK&lt;/<span class="hljs-built_in">param</span>-<span class="hljs-built_in">value</span>&gt;&lt;/init-<span class="hljs-built_in">param</span>&gt;</code></pre></div></li><li><p>配置信息是在 servlet初始化的时候加载到 servletConfig 对象里</p><div class="hljs"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ServletConfig <span class="hljs-built_in">config</span>)</span> throws ServletException</span></code></pre></div></li><li><p>获取这个配置信息  获取的时候也是以键来获取值</p><div class="hljs"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    public void init(<span class="hljs-type">ServletConfig</span> config) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span> &#123;        <span class="hljs-type">Enumeration</span> enumeration=config.getInitParameterNames();        <span class="hljs-keyword">while</span> (enumeration.hasMoreElements())&#123;            <span class="hljs-type">String</span> key=(<span class="hljs-type">String</span>)enumeration.nextElement();            <span class="hljs-type">System</span>.out.println(key+<span class="hljs-string">"\t"</span>+config.getInitParameter(key));        &#125;    &#125;</code></pre></div></li></ul><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>ServletContext是一个全局对象（上下文对象）在web项目发布的时候  每一个web项目都会创建这样一样用于来获取整个web项目的配置信息的对象<br>servletContext  设置的配置文件  所以servlet共享 都可以获取到<br>使用步骤：</p><ul><li><p>在web.xml进行配置，不是在servlet节点下设置</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>age<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>12<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span></code></pre></div></li><li><p>.获取ServletContext的对象</p><div class="hljs"><pre><code class="hljs abnf">this.getServletContext()<span class="hljs-comment">;</span>req.getServletContext()<span class="hljs-comment">;</span></code></pre></div></li><li><p>获取设置的值  以兼职对的方式来进行获取</p><div class="hljs"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> void doPost(<span class="hljs-type">HttpServletRequest</span> req, <span class="hljs-type">HttpServletResponse</span> resp) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;        <span class="hljs-type">Enumeration</span> enumeration=req.getServletContext().getInitParameterNames();        <span class="hljs-keyword">while</span> (enumeration.hasMoreElements())&#123;            <span class="hljs-type">String</span> key=(<span class="hljs-type">String</span>)enumeration.nextElement();            <span class="hljs-type">System</span>.out.println(key+<span class="hljs-string">"\t"</span>+req.getServletContext().getInitParameter(key));        &#125;    &#125;&#125;</code></pre></div></li></ul><h4 id="重定向与转发"><a href="#重定向与转发" class="headerlink" title="重定向与转发"></a>重定向与转发</h4><p>作用都是实现页面的跳转</p><div class="hljs"><pre><code class="hljs less"><span class="hljs-selector-tag">req</span><span class="hljs-selector-class">.getRequestDispatcher</span>(<span class="hljs-string">"转发的url地址"</span>)<span class="hljs-selector-class">.forward</span>(req, resp);<span class="hljs-selector-tag">resp</span><span class="hljs-selector-class">.sendRedirect</span>(<span class="hljs-string">"重定向的地址"</span>)</code></pre></div><p>转发的原理 :转发是在服务器内部执行的 url地址是不会改变  一次请求<br>       重定向:在客户端执行  url地址会发生改变  相当于是两次请求</p><h4 id="重定向与转发的区别"><a href="#重定向与转发的区别" class="headerlink" title="重定向与转发的区别"></a>重定向与转发的区别</h4><ul><li>转发 在服务器执行 重定向是 客户端执行</li><li>转发 url地址不会发生改变   重定向url会发生改变</li><li>转发可以携带参数  重定向 不可以携带参数</li><li>转发是一次请求   重定向是两次请求</li><li>转发不能从a项目跳转到b项目   重定向是可以a项目跳转b项目</li><li>转发的效率更高   重定向效率相对于低</li><li>查询 使用转发    增删改成功之后  使用重定向 </li></ul><h4 id="作用域对象"><a href="#作用域对象" class="headerlink" title="作用域对象"></a>作用域对象</h4><ul><li><p>在生命周期内可以获取 设置 删除 属性的对象  就是作用域对象 类似与变量</p></li><li><p>两个作用域对象  ServletContext  request 对象</p></li><li><p>常用的三个方法<br>$$<br>req.setAttribute(“键”,”值”);<br>req.removeAttribute(“键”);//根据键来删除值<br>$$</p></li></ul><h4 id="request-的作用域"><a href="#request-的作用域" class="headerlink" title="request 的作用域:"></a>request 的作用域:</h4><ul><li>没有调用removeAttribute() 是可以获取到</li><li>在一次请求中都可以获取到 重定向是获取不到的</li></ul><h4 id="ServletContext-对象-作用域"><a href="#ServletContext-对象-作用域" class="headerlink" title="ServletContext 对象 作用域"></a>ServletContext 对象 作用域</h4><ul><li>没有调用removeAttribute() 是可以获取到</li><li>只要服务器没有关闭  都可以获取 不管转发还是重定向</li></ul><h4 id="servlet注解"><a href="#servlet注解" class="headerlink" title="servlet注解"></a>servlet注解</h4><h6 id="1-在jdk1-5之后可以使用注解-作用简化代码"><a href="#1-在jdk1-5之后可以使用注解-作用简化代码" class="headerlink" title="1.在jdk1.5之后可以使用注解 作用简化代码"></a>1.在jdk1.5之后可以使用注解 作用简化代码</h6><p>   2.使用webServlet 注解来替换我们web.xml的配置<br>   3.使用:</p><div class="hljs"><pre><code class="hljs scala"><span class="hljs-meta">@WebServlet</span>(name = <span class="hljs-string">"demoServlet"</span> ,urlPatterns = <span class="hljs-string">"/demoServlet"</span>)public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;...&#125;</code></pre></div><p> 4.webServlet注解是在web 3.0才能使用   </p><ul><li>注解的加载的顺序 是按照你名字的首字母进行加载</li><li>注解与web.xml 不能够同时存在 只能够存在一个</li></ul><h2 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h2><ul><li><p>xml 可扩展标记语言==&gt;html的前身html 很多东西都是引入xml  html5 =xml+html4.0</p></li><li><p>作用: 用于来保存数据(很少使用)   用于来写配置文件  一般框架的配置信息都是xml</p></li><li><p>xml 与html的区别:</p><div class="hljs"><pre><code>html的标签 预定义的  xml的标签都是 自定义 任意定义html 主要用显示  页面比较好  xml 用于保存数据</code></pre></div></li></ul><h4 id="xml编写的注意事项"><a href="#xml编写的注意事项" class="headerlink" title="xml编写的注意事项"></a>xml编写的注意事项</h4><ul><li>xml必须存在只能 一个根节点</li><li>xml标签是区分大小写</li><li>标签都是成对出现</li><li>标签的名称 通俗易懂 尽量使用英文 不要使用数字</li><li>标签必须正确的嵌套</li></ul><h4 id="XML的解析"><a href="#XML的解析" class="headerlink" title="XML的解析"></a>XML的解析</h4><p>xml的解析也就是读取xml的数据</p><p>web开发 dom  dom 4j  ==&gt;需要的内存比较大 会把整个xml加载到内存 ，然后再进行解析  移动端使用xpath  sax   读取一行解析一行，因为移动端比较小</p><h4 id="dom解析"><a href="#dom解析" class="headerlink" title="dom解析"></a>dom解析</h4><ul><li><p>把xml转换成dom对象</p>  <div class="hljs"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> Document doc;            <span class="hljs-comment">//把xml转换成dom对象</span>    public void get<span class="hljs-constructor">Dom()</span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//得到doc解析工厂类</span>            DocumentBuilderFactory dbf=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DocumentBuilderFactory</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;            <span class="hljs-comment">//通过解析工厂得到解析器</span>            DocumentBuilder db=dbf.<span class="hljs-keyword">new</span><span class="hljs-constructor">DocumentBuilder()</span>;            <span class="hljs-comment">//调用方法把文件转换成dom对象</span>            doc=db.parse(<span class="hljs-keyword">new</span> <span class="hljs-constructor">File(<span class="hljs-string">"src/收藏信息.xml"</span>)</span>);        &#125; catch (ParserConfigurationException e) &#123;            e.print<span class="hljs-constructor">StackTrace()</span>;        &#125; catch (SAXException e) &#123;            e.print<span class="hljs-constructor">StackTrace()</span>;        &#125; catch (IOException e) &#123;            e.print<span class="hljs-constructor">StackTrace()</span>;        &#125;    &#125;</code></pre></div></li><li><p>查询数据</p>  <div class="hljs"><pre><code class="hljs reasonml">public void select<span class="hljs-literal">()</span>&#123;       <span class="hljs-comment">//根据名称获取所有节点对象</span>       NodeList nodeList=doc.get<span class="hljs-constructor">ElementsByTagName(<span class="hljs-string">"Brand"</span>)</span>;       for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;nodeList.get<span class="hljs-constructor">Length()</span>;i++)&#123;           <span class="hljs-comment">//遍历得到每一个节点对象</span>           Node node=nodeList.item(i);           <span class="hljs-comment">//把节点对象转换成节点属性</span>           Element elementBrand=(Element)node;           <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(elementBrand.get<span class="hljs-constructor">Attribute(<span class="hljs-string">"name"</span>)</span>);           <span class="hljs-comment">//获取所有的子节点</span>           NodeList nodeTypeList=elementBrand.get<span class="hljs-constructor">ChildNodes()</span>;           for(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;nodeTypeList.get<span class="hljs-constructor">Length()</span>;j++)&#123;               <span class="hljs-comment">//获取每一个节点</span>              Node nodeType=nodeTypeList.item(i);              <span class="hljs-comment">//判断是否是元素节点</span>              <span class="hljs-keyword">if</span>(nodeType.get<span class="hljs-constructor">NodeType()</span>==Element.ELEMENT_NODE) &#123;                  <span class="hljs-comment">//如果是节点进行强制类型转换</span>                  Element elementType = (Element) nodeType;                  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(elementType.get<span class="hljs-constructor">Attribute(<span class="hljs-string">"name"</span>)</span>);              &#125;           &#125;       &#125;   &#125;</code></pre></div></li><li><p>把dom对象写入到文件中</p>  <div class="hljs"><pre><code class="hljs reasonml">public void write<span class="hljs-constructor">Doc()</span>&#123;    <span class="hljs-keyword">try</span> &#123;   <span class="hljs-comment">//得到写入的对象工厂</span>        TransformerFactory tff=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TransformerFactory</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;        Transformer tf=tff.<span class="hljs-keyword">new</span><span class="hljs-constructor">Transformer()</span>;        Source source=<span class="hljs-keyword">new</span> <span class="hljs-constructor">DOMSource(<span class="hljs-params">doc</span>)</span>;        Result result=<span class="hljs-keyword">new</span> <span class="hljs-constructor">StreamResult(<span class="hljs-params">new</span> OutputStreamWriter(<span class="hljs-params">new</span> FileOutputStream(<span class="hljs-string">"3.xml"</span>)</span>,<span class="hljs-string">"UTF-8"</span>));        tf.transform(source, result);    &#125; catch (UnsupportedEncodingException e) &#123;        e.print<span class="hljs-constructor">StackTrace()</span>;    &#125; catch (FileNotFoundException e) &#123;        e.print<span class="hljs-constructor">StackTrace()</span>;    &#125; catch (TransformerException e) &#123;        e.print<span class="hljs-constructor">StackTrace()</span>;    &#125;&#125;</code></pre></div></li><li><p>增加一个节点:</p>  <div class="hljs"><pre><code class="hljs reasonml">public  void add<span class="hljs-literal">()</span>&#123;     Element elementBrand=doc.create<span class="hljs-constructor">Element(<span class="hljs-string">"Brand"</span>)</span>;     elementBrand.set<span class="hljs-constructor">Attribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"小米"</span>)</span>;     Element elementType=doc.create<span class="hljs-constructor">Element(<span class="hljs-string">"Type"</span>)</span>;     elementType.set<span class="hljs-constructor">Attribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"小米11"</span>)</span>;     elementBrand.append<span class="hljs-constructor">Child(<span class="hljs-params">elementType</span>)</span>;     doc.get<span class="hljs-constructor">ElementsByTagName(<span class="hljs-string">"PhoneInfo"</span>)</span>.item(<span class="hljs-number">0</span>).append<span class="hljs-constructor">Child(<span class="hljs-params">elementBrand</span>)</span>; &#125;</code></pre></div></li><li><p>删除节点:</p>  <div class="hljs"><pre><code class="hljs reasonml">public void delete<span class="hljs-literal">()</span>&#123;       NodeList nodeBrandList= doc.get<span class="hljs-constructor">ElementsByTagName(<span class="hljs-string">"Brand"</span>)</span>;       for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;nodeBrandList.get<span class="hljs-constructor">Length()</span>;i++)&#123;           Node nodeBrand=nodeBrandList.item(i);           Element elementBrand=(Element) nodeBrand;           <span class="hljs-keyword">if</span>(<span class="hljs-string">"华为"</span>.equals(elementBrand.get<span class="hljs-constructor">Attribute(<span class="hljs-string">"name"</span>)</span>))&#123;               elementBrand.get<span class="hljs-constructor">ParentNode()</span>.remove<span class="hljs-constructor">Child(<span class="hljs-params">elementBrand</span>)</span>;           &#125;       &#125;  &#125;</code></pre></div></li><li><p>修改属性节点</p>  <div class="hljs"><pre><code class="hljs matlab">public void update()&#123;      NodeList nodeList=doc.getElementsByTagName(<span class="hljs-string">"Brand"</span>);      <span class="hljs-keyword">for</span>(int <span class="hljs-built_in">i</span>=<span class="hljs-number">0</span>;<span class="hljs-built_in">i</span>&lt;nodeList.getLength();<span class="hljs-built_in">i</span>++)&#123;          Node node=nodeList.item(<span class="hljs-built_in">i</span>);          Element element=(Element)node;          element.setAttribute(<span class="hljs-string">"id"</span>, (<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>)+<span class="hljs-string">""</span>);      &#125; &#125;</code></pre></div></li></ul><h4 id="dom4j解析"><a href="#dom4j解析" class="headerlink" title="dom4j解析"></a>dom4j解析</h4><ul><li><p>把xml转换成doc 对象 </p>  <div class="hljs"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getDoc</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            SAXReader sr=<span class="hljs-keyword">new</span> SAXReader();           doc=sr.<span class="hljs-built_in">read</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">File</span>(<span class="hljs-string">"src/收藏信息.xml"</span>));        &#125; <span class="hljs-keyword">catch</span> (DocumentException e) &#123;            e.printStackTrace();        &#125;    &#125;</code></pre></div></li></ul><ul><li><p>查询数据 </p><p>  添加</p>  <div class="hljs"><pre><code class="hljs reasonml">public void add<span class="hljs-literal">()</span>&#123;       Element elementRoot=doc.get<span class="hljs-constructor">RootElement()</span>;     Element elementBrand =elementRoot.add<span class="hljs-constructor">Element(<span class="hljs-string">"Brand"</span>)</span>;     elementBrand.add<span class="hljs-constructor">Attribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"SONY"</span>)</span>;     Element elementType=elementBrand.add<span class="hljs-constructor">Element(<span class="hljs-string">"Type"</span>)</span>;     elementType.add<span class="hljs-constructor">Attribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"xzp"</span>)</span>;   &#125;</code></pre></div><p>  删除</p>  <div class="hljs"><pre><code class="hljs routeros">public void delete()&#123;        Element <span class="hljs-attribute">element</span>=doc.getRootElement();        Iterator&lt;Element&gt; <span class="hljs-attribute">elementIterator</span>=element.elementIterator();        <span class="hljs-keyword">while</span> (elementIterator.hasNext())&#123;            Element <span class="hljs-attribute">elementBrand</span>=elementIterator.next();            <span class="hljs-keyword">if</span>(<span class="hljs-string">"华为"</span>.equals(elementBrand.attributeValue(<span class="hljs-string">"name"</span>)))&#123;                elementBrand.getParent().<span class="hljs-builtin-name">remove</span>(elementBrand);            &#125;        &#125;&#125;</code></pre></div><p>  查询</p>  <div class="hljs"><pre><code class="hljs reasonml"> public void select<span class="hljs-literal">()</span>&#123;        Element elementRoot=doc.get<span class="hljs-constructor">RootElement()</span>;        Iterator iterator=elementRoot.element<span class="hljs-constructor">Iterator()</span>;        <span class="hljs-keyword">while</span> (iterator.has<span class="hljs-constructor">Next()</span>)&#123;            Element elementBrand=(Element)iterator.next<span class="hljs-literal">()</span>;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(elementBrand.attribute<span class="hljs-constructor">Value(<span class="hljs-string">"name"</span>)</span>);            Iterator iteratorType=elementBrand.element<span class="hljs-constructor">Iterator()</span>;           <span class="hljs-keyword">while</span> (iteratorType.has<span class="hljs-constructor">Next()</span>)&#123;               Element elementType=(Element) iteratorType.next<span class="hljs-literal">()</span>;               <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(elementType.attribute<span class="hljs-constructor">Value(<span class="hljs-string">"name"</span>)</span>);            &#125;<span class="hljs-comment">//两种迭代方式</span>       <span class="hljs-comment">/*     for(Iterator iteratorType1=elementBrand.elementIterator();iteratorType1.hasNext();)&#123;</span><span class="hljs-comment">               Element elementType1=(Element)iteratorType1.next();</span><span class="hljs-comment">                System.out.println(elementType1.attributeValue("name"));</span><span class="hljs-comment">            &#125;</span><span class="hljs-comment">*/</span>        &#125;    &#125;</code></pre></div><p>  写</p>  <div class="hljs"><pre><code class="hljs reasonml">public void writer<span class="hljs-constructor">Doc()</span>&#123;       <span class="hljs-keyword">try</span> &#123;           OutputStream out=<span class="hljs-keyword">new</span> <span class="hljs-constructor">FileOutputStream(<span class="hljs-string">"5.xml"</span>)</span>;           OutputFormat format=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">OutputFormat</span>.</span></span>create<span class="hljs-constructor">PrettyPrint()</span>;           XMLWriter writer=<span class="hljs-keyword">new</span> <span class="hljs-constructor">XMLWriter(<span class="hljs-params">out</span>,<span class="hljs-params">format</span>)</span>;           writer.write(doc);           writer.flush<span class="hljs-literal">()</span>;           writer.close<span class="hljs-literal">()</span>;       &#125; catch (IOException e) &#123;           e.print<span class="hljs-constructor">StackTrace()</span>;       &#125;   &#125;</code></pre></div><p>  主方法调用</p>  <div class="hljs"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> &#123;</span>    <span class="hljs-keyword">private</span> Document doc;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        Test1 test1=<span class="hljs-keyword">new</span> Test1();        test1.getDoc();        <span class="hljs-comment">/*test1.add();*/</span>        test1.<span class="hljs-keyword">delete</span>();        test1.writerDoc();        <span class="hljs-comment">/*test1.select();*/</span>    &#125;</code></pre></div></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HttpServletRequest</title>
    <link href="/2020/06/03/HttpServletRequest/"/>
    <url>/2020/06/03/HttpServletRequest/</url>
    
    <content type="html"><![CDATA[<h6 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h6><ul><li>导包是javax.servlet.http</li><li>父类：ServletRequest</li><li>区别：HttpServletRequest是对ServletRequest的升级，支持http协议，</li><li>HttpServletRequest 是由tomcat创建，是调用service方法的创建</li><li>HttpServletRequest 一般是用于做请求，请求行，请求头，请求体</li><li>HttpServletRequest 请求行一般是用获取服务器一些信息 ip  端口号 项目名称  访问路径 参数…</li></ul><h6 id="HttpServletRespone"><a href="#HttpServletRespone" class="headerlink" title="HttpServletRespone"></a>HttpServletRespone</h6><ul><li>导包是javax.servlet.http</li><li>父类：ServletRespone</li><li>区别：HttpServletRespone是对ServletRespones的升级，支持http协议，</li><li>HttpServletRespone是由tomcat创建，是调用service方法的创建</li><li>HttpServletRespone一般是用于做响应，响应行，响应头，响应体</li></ul><h6 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h6><ul><li>http是一个超文本协议，主要用于传输文本，是一个一次性的协议，请求完服务器给响应，这次连接就断开了，http协议底层是tcp协议</li><li>http 0.9  只用于传输普通文本</li><li>http 1.0 支持长连接，连接成功后，隔多长时间不发送请求会自动断开</li></ul><h6 id="tcp三次握手："><a href="#tcp三次握手：" class="headerlink" title="tcp三次握手："></a>tcp三次握手：</h6><p>目的:建立连接</p><ul><li><p>​      第一次   客户端向服务器发送请求，服务器接收到这次请求   </p></li><li><p>​      第二次  客户端收到服务器的响应</p></li><li><p>​      第三次  客户端向服务器发送数据  ，示连接成功 </p></li><li></li></ul><h6 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h6><ul><li>1xx  :服务器连接成功，可以继续操作</li><li>2xx :响应成功，200</li><li>3xx :表示重定向 ，跳转地址</li><li>4xx ;页面路径找不到</li><li>5xx :服务器代码发生错误</li></ul><p>常规状态码：</p><p>200 成功；404 页面找不到；500 服务器代码发生错误</p><ol><li>出现404的情况;</li></ol><ul><li><p>页面的路径写错，导致页面找不到</p></li><li><p>tomcat没部署web项目</p></li><li><p>路径层次太深</p></li></ul><ol start="2"><li>出现500的情况：</li></ol><ul><li>查看控制台日志，找到具体的代码错误行，</li></ul><div class="hljs"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> void service(<span class="hljs-type">HttpServletRequest</span> req, <span class="hljs-type">HttpServletResponse</span> resp) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;        <span class="hljs-keyword">try</span> &#123;            int i=<span class="hljs-number">1</span>/<span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-type">Exception</span> e) &#123;            resp.sendError(<span class="hljs-number">500</span>, <span class="hljs-string">"除数不能为0"</span>);            e.printStackTrace();        &#125;    &#125;&#125;</code></pre></div><h6 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h6><ul><li>Location : 重定向，多少秒刷新页面</li><li>Content-Type : text/htm;charset=utf-8 设置响应的编码格式</li><li>Content-desponsition ： 用于文件下载</li><li>Conten-Encoding  ：设置响应的压缩类型</li><li>Date  :  用于记录服务器响应的时间</li></ul><div class="hljs"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> void service(<span class="hljs-type">HttpServletRequest</span> req, <span class="hljs-type">HttpServletResponse</span> resp) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;        resp.setHeader(<span class="hljs-string">"Connet-Type"</span>, <span class="hljs-string">"image/jpg"</span>);        java.io.<span class="hljs-type">InputStream</span> is=<span class="hljs-keyword">this</span>.getServletContext().getResourceAsStream(<span class="hljs-string">"WEB-INF/admin.jpg"</span>);        <span class="hljs-type">ServletOutputStream</span> outputStream=resp.getOutputStream();        byte[] bytes=<span class="hljs-keyword">new</span> byte[<span class="hljs-number">1024</span>];        int leng=<span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>((leng=is.read(bytes))!=<span class="hljs-number">-1</span>)&#123;            outputStream.write(bytes,<span class="hljs-number">0</span>,leng);        &#125;    &#125;&#125;</code></pre></div><h6 id="把一个图片响应写在浏览器"><a href="#把一个图片响应写在浏览器" class="headerlink" title="把一个图片响应写在浏览器"></a>把一个图片响应写在浏览器</h6><p>服务器存在一张图片 需要把图片直接读取到浏览器里 通过响应头来进行设置</p><p>分析: InputStream  outputSteam</p><ul><li>把图片放入到web-info下 </li><li>使用流来进行读写操作</li></ul><div class="hljs"><pre><code class="hljs reasonml">resp.set<span class="hljs-constructor">Header(<span class="hljs-string">"Connet-Type"</span>, <span class="hljs-string">"image/jpg"</span>)</span>;<span class="hljs-comment">//设置响应的格式是图片</span>InputStream is=this.get<span class="hljs-constructor">ServletContext()</span>.get<span class="hljs-constructor">ResourceAsStream(<span class="hljs-string">"WEB-INF/admin.jpg"</span>)</span>;<span class="hljs-comment">//把服务器上的图片转换为输入流</span>        ServletOutputStream outputStream=resp.get<span class="hljs-constructor">OutputStream()</span>;        <span class="hljs-comment">//读写操作</span>        byte<span class="hljs-literal">[]</span> <span class="hljs-built_in">bytes</span>=<span class="hljs-keyword">new</span> byte<span class="hljs-literal">[<span class="hljs-number">1024</span>]</span>;        <span class="hljs-built_in">int</span> leng=-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>((leng=is.read(<span class="hljs-built_in">bytes</span>))!=-<span class="hljs-number">1</span>)&#123;            outputStream.write(<span class="hljs-built_in">bytes</span>,<span class="hljs-number">0</span>,leng);                    &#125;</code></pre></div><h6 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h6><ul><li>界面需要写一个跳转标签，要传递参数为图片的名称</li><li>使用流进行读写操作</li><li>设置Content-Desposition  ，告诉浏览器是以下载的方式打开</li></ul><div class="hljs"><pre><code class="hljs xml">index.jsp设置：<span class="hljs-tag">&lt;<span class="hljs-name">%@</span> <span class="hljs-attr">page</span> <span class="hljs-attr">contentType</span>=<span class="hljs-string">"text/html;charset=UTF-8"</span> <span class="hljs-attr">language</span>=<span class="hljs-string">"java"</span> %&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>$Title$<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"userServlet?filename=admin.jpg"</span>&gt;</span>下载<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> void service(<span class="hljs-type">HttpServletRequest</span> req, <span class="hljs-type">HttpServletResponse</span> resp) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;       <span class="hljs-type">String</span> filename=req.getParameter(<span class="hljs-string">"filename"</span>);       resp.setHeader(<span class="hljs-string">"Content-Disposition"</span>, <span class="hljs-string">"attachment;filename="</span> +filename);        java.io.<span class="hljs-type">InputStream</span> is=<span class="hljs-keyword">this</span>.getServletContext().getResourceAsStream(<span class="hljs-string">"WEB-INF/admin.jpg"</span>);        <span class="hljs-type">ServletOutputStream</span> outputStream=resp.getOutputStream();        byte[] bytes=<span class="hljs-keyword">new</span> byte[<span class="hljs-number">1024</span>];        int leng=<span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>((leng=is.read(bytes))!=<span class="hljs-number">-1</span>)&#123;            outputStream.write(bytes,<span class="hljs-number">0</span>,leng);        &#125;    &#125;&#125;</code></pre></div><h6 id="响应头-1"><a href="#响应头-1" class="headerlink" title="响应头"></a>响应头</h6><p>常规的响应头：</p><ul><li>.Location =&gt;表示重定向  ==&gt;个多秒刷新页面</li><li>.Content-Type==&gt; text/htm;charset=utf-8设置响应的编码格式</li><li>Content-desposition  一般用于文件下载</li><li>Content-Encoding  表示设置响应的压缩类型</li><li>.Date 用于来记录服务器响应的时间</li></ul><p>设置响应头：</p><ul><li>resp.setHeader(s:”设置头的状态”，s1:”具体的值”)；  追加多个状态值，会覆盖</li><li>resp.addHeader(s:”设置头的状态”，s1:”具体的值”)；此方法可以追加多个状态值，不会覆盖</li></ul><h6 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h6><p>resp.getOutputStream() : </p><p>resp.getWriter() : 写普通文本</p><p>&lt;<em>web-inf下的资源 通过，路劲是直接获取不到 页面不要放入到web-inf下</em>&gt;</p><div class="hljs"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> UserServlet extends HttpServlet &#123;    @Override    protected <span class="hljs-type">void</span> service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    //响应的编码格式        resp.setContentType("text/html;charset=utf-8");        PrintWriter <span class="hljs-keyword">out</span>=resp.getWriter();        <span class="hljs-keyword">out</span>.<span class="hljs-keyword">write</span>("&lt;table border='1'&gt;");        <span class="hljs-keyword">out</span>.<span class="hljs-keyword">write</span>("&lt;tr&gt;");        <span class="hljs-keyword">out</span>.<span class="hljs-keyword">write</span>("&lt;td&gt;闪闪&lt;/td&gt;");        <span class="hljs-keyword">out</span>.<span class="hljs-keyword">write</span>("&lt;td&gt;Archar&lt;/td&gt;");        <span class="hljs-keyword">out</span>.<span class="hljs-keyword">write</span>("&lt;td&gt;哈哈哈&lt;/td&gt;");        <span class="hljs-keyword">out</span>.<span class="hljs-keyword">write</span>("&lt;/tr&gt;");        <span class="hljs-keyword">out</span>.<span class="hljs-keyword">write</span>("&lt;/table&gt;");        <span class="hljs-keyword">out</span>.flush();//关闭资源        <span class="hljs-keyword">out</span>.<span class="hljs-keyword">close</span>();    &#125;</code></pre></div><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">闪闪</td><td align="center">Archar</td><td align="center">哈哈哈</td></tr></tbody></table><h6 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h6><p>请求头是在发现数据的时候 请求的一些配置信息,这个信息不要设置 ,浏览器自己处理我们只需要获取</p><div class="hljs"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> void service(<span class="hljs-type">HttpServletRequest</span> req, <span class="hljs-type">HttpServletResponse</span> resp) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;        <span class="hljs-type">Enumeration</span>&lt;<span class="hljs-type">String</span>&gt; enumeration=req.getHeaderNames();        <span class="hljs-keyword">while</span>(enumeration.hasMoreElements())&#123;            <span class="hljs-type">String</span> key=enumeration.nextElement();            <span class="hljs-type">System</span>.out.println(key+<span class="hljs-string">"\t"</span>+req.getHeader(key));        &#125;    &#125;&#125;</code></pre></div><h6 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h6><ul><li><p>用于获取请求传递的参数</p></li><li><p>两个方法</p></li><li><p>据注意点： 所以的数据提交 都是根据name来获取其值所有的提交获取的都是其value值</p><div class="hljs"><pre><code class="hljs less"><span class="hljs-selector-tag">req</span><span class="hljs-selector-class">.getParameter</span>(<span class="hljs-attribute">s</span>:<span class="hljs-string">" "</span>);   <span class="hljs-comment">//获取单个</span><span class="hljs-selector-tag">req</span><span class="hljs-selector-class">.getParameterValues</span>();  <span class="hljs-comment">//获取一组数</span></code></pre></div></li></ul><div class="hljs"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> void service(<span class="hljs-type">HttpServletRequest</span> req, <span class="hljs-type">HttpServletResponse</span> resp) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;        req.setCharacterEncoding(<span class="hljs-string">"utf-8"</span>);        resp.setContentType(<span class="hljs-string">"text/html;charset=utf-8"</span>);        <span class="hljs-type">String</span> uname=req.getParameter(<span class="hljs-string">"uname"</span>);        <span class="hljs-type">String</span> pwd=req.getParameter(<span class="hljs-string">"pwd"</span>);        <span class="hljs-type">String</span> sex=req.getParameter(<span class="hljs-string">"sex"</span>);        <span class="hljs-type">String</span>[] str=req.getParameterValues(<span class="hljs-string">"sp"</span>);        <span class="hljs-keyword">if</span>(str !=<span class="hljs-literal">null</span> &amp;&amp; str.length&gt;<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">String</span> s:str)&#123;                <span class="hljs-type">System</span>.out.println(s);            &#125;        &#125;    &#125;&#125;</code></pre></div><h6 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h6><ul><li><p>上传的时候 from 表单 必须是post提交  </p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">enctype</span>=<span class="hljs-string">"multipart/form-data"</span></code></pre></div></li><li><p>页面</p><div class="hljs"><pre><code class="hljs routeros">&lt;form <span class="hljs-attribute">method</span>=<span class="hljs-string">"post"</span> <span class="hljs-attribute">enctype</span>=<span class="hljs-string">"multipart/form-data"</span>&gt;   &lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">"file"</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">"uanme"</span>&gt;   &lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">"提交"</span>&gt;</code></pre></div></li><li><p>添加jar包 并加入依赖</p><div class="hljs"><pre><code class="hljs angelscript">commons-fileupload<span class="hljs-number">-1.2</span><span class="hljs-number">.1</span>commons-io<span class="hljs-number">-1.4</span></code></pre></div></li></ul><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>web相关知识</title>
    <link href="/2020/06/02/web%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2020/06/02/web%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h5 id="web简介"><a href="#web简介" class="headerlink" title="web简介"></a>web简介</h5><ol><li><p>web开发: 前端开发 网站开发  java 中的web开发 不只有前端 还需要写后台</p></li><li><p>web资源 :也就网页上一些可以看见的就是web资源 比如图片 视频 标签 主要用于页面的</p></li><li><p>web的架构: c/s 架构  b/s架构</p></li></ol><h5 id="c-s架构-也就是客户端与服务器直接进行交互，"><a href="#c-s架构-也就是客户端与服务器直接进行交互，" class="headerlink" title="c/s架构 : 也就是客户端与服务器直接进行交互，"></a>c/s架构 : 也就是客户端与服务器直接进行交互，</h5><ul><li><p>优点:速度快 效率高,安全性比较高,不需要依赖与浏览器 但是需要较高的电脑配置</p></li><li><p>缺点:  必须在客户端安装相应的程序  维护升级比较麻烦</p></li></ul><h5 id="b-s架构-客户端向浏览器发送-gt-浏览器再向服务器发送请求"><a href="#b-s架构-客户端向浏览器发送-gt-浏览器再向服务器发送请求" class="headerlink" title="b/s架构: 客户端向浏览器发送 ==&gt; 浏览器再向服务器发送请求"></a>b/s架构: 客户端向浏览器发送 ==&gt; 浏览器再向服务器发送请求</h5><ul><li><p>优点:  维护升级方便  无缝进行替换</p></li><li><p>缺点: 速度慢依赖于浏览器 有些低版本浏览器动画效果是不能够显示</p></li><li><p>b/s架构的请求原理: </p><p>​      建议连接 ==&gt;索取微信号</p><p>​      聊天 =&gt;发送请求  </p><p>​      聊天  接收到请求  给其响应</p><p>​     请求连接关闭  </p><p>​     先发送请求 再有响应  请求与响应的是配套的</p></li></ul><h5 id="Web服务器的介绍"><a href="#Web服务器的介绍" class="headerlink" title="Web服务器的介绍"></a>Web服务器的介绍</h5><p> Web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，可以向浏览器等Web客户端提供文档，也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载。目前最主流的三个Web服务器是tomcat 、 weblogic 、IIS</p><p> url 地址: 统一资源定位符 ，也就是访问的路劲  只要是放在服务器上的  图片  页面 每一个都存在访问的路劲  </p><p>  url的组成部分：</p><p><a href="https://uland.taobao.com/sem/tbsearch?refpid=mm_26632258_3504122_32538762&amp;keyword=%E5%A5%B3%E8%A3%85&amp;clk1=c08fa79f9cd4b9e6c7727282760c1c1c&amp;upsid=c08fa79f9cd4b9e6c7727282760c1c1c" target="_blank" rel="noopener">https://uland.taobao.com/sem/tbsearch?refpid=mm_26632258_3504122_32538762&amp;keyword=%E5%A5%B3%E8%A3%85&amp;clk1=c08fa79f9cd4b9e6c7727282760c1c1c&amp;upsid=c08fa79f9cd4b9e6c7727282760c1c1c</a></p><ul><li>https  http 请求的协议</li><li>uland.taobao.com  域名或者是ip地址</li><li>sem/tbsearch 访问具体的资源的路劲</li><li>？后面都是以键值对的形式向服务器传递的参数   多个参数 &amp;进行拼接</li></ul><h4 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h4><ol><li><p>servlet 是运行在服务器的Java代码  主要用与做处理请求与响应  java web三大主组件之一</p></li><li><p>servlet的使用的步骤:</p></li></ol><ul><li>新建一个项目，配置tomcat服务器</li><li>在idea中添加servletjar</li><li>在web.xml配置servlet</li></ul><h4 id="servlet类的实现方式"><a href="#servlet类的实现方式" class="headerlink" title="servlet类的实现方式"></a>servlet类的实现方式</h4><div class="hljs"><pre><code class="hljs scala">最常用的方式：public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    public void service(<span class="hljs-type">ServletRequest</span> req, <span class="hljs-type">ServletResponse</span> res) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;        <span class="hljs-keyword">super</span>.service(req, res);    &#125;&#125;</code></pre></div><h4 id="servlet的生命周期"><a href="#servlet的生命周期" class="headerlink" title="servlet的生命周期"></a>servlet的生命周期</h4><ul><li><p>servlet是由tomcat容器创建 是在运行tomcat 的时候创建 所以用到 —servlet都需要添加tomcat的lib的jar</p></li><li><p>init() 表示servlet初始化 有且只执行一次  单例设置模式</p></li><li><p>service()方法 所以的请求与响应都会执行这个方法</p></li><li><p>destory() 方法 servlet销毁的执行这个方法  也就tomcat服务器关闭的时候执行</p></li><li><p>servlet 的生命周期是随着tomcat的开始而开始 结束而结束</p></li></ul><div class="hljs"><pre><code class="hljs applescript">&lt;load-<span class="hljs-keyword">on</span>-startup&gt;<span class="hljs-number">-1</span>&lt;/load-<span class="hljs-keyword">on</span>-startup&gt;</code></pre></div><p>设置这个表示 立即加载 是要是&gt;=0 就可以 可以为负数  默认值就是负数  最优先加载，值越小越优先加载</p><h5 id="servlet-访问路劲-通配符设置"><a href="#servlet-访问路劲-通配符设置" class="headerlink" title="servlet 访问路劲 通配符设置"></a>servlet 访问路劲 通配符设置</h5><ul><li><p>/*    表示所有的请求与响应都会执行这个servlet</p></li><li><p>/userservlet  表示 请求是userServlet的时候才会执行这个servlet</p></li><li><p>/admin/* 访问的路劲是admin文件下所有的文件都会执行这个servlet</p></li><li><p>*.do 表示.do结尾的请求路劲都会执行这个servlet</p></li></ul><h4 id="get-post区"><a href="#get-post区" class="headerlink" title="get post区"></a>get post区</h4><ul><li><p>get提交数据 浏览器会缓存数据</p></li><li><p>get提交数据有长度限制</p></li><li><p>get提交数据有大小限制</p></li><li><p>get一般用与文件下载</p></li></ul><p>  post：</p><ul><li><p>post提交数据 不会缓存数据到浏览器</p></li><li><p>post提交数据没有长度限制</p></li><li><p>post提交数据有加密 安全性高</p></li><li><p>post 一般用于表单提交</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
