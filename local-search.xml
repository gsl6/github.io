<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HttpServletRequest</title>
    <link href="/2020/06/03/HttpServletRequest/"/>
    <url>/2020/06/03/HttpServletRequest/</url>
    
    <content type="html"><![CDATA[<h6 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h6><ul><li>导包是javax.servlet.http</li><li>父类：ServletRequest</li><li>区别：HttpServletRequest是对ServletRequest的升级，支持http协议，</li><li>HttpServletRequest 是由tomcat创建，是调用service方法的创建</li><li>HttpServletRequest 一般是用于做请求，请求行，请求头，请求体</li><li>HttpServletRequest 请求行一般是用获取服务器一些信息 ip  端口号 项目名称  访问路径 参数…</li></ul><h6 id="HttpServletRespone"><a href="#HttpServletRespone" class="headerlink" title="HttpServletRespone"></a>HttpServletRespone</h6><ul><li>导包是javax.servlet.http</li><li>父类：ServletRespone</li><li>区别：HttpServletRespone是对ServletRespones的升级，支持http协议，</li><li>HttpServletRespone是由tomcat创建，是调用service方法的创建</li><li>HttpServletRespone一般是用于做响应，响应行，响应头，响应体</li></ul><h6 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h6><ul><li>http是一个超文本协议，主要用于传输文本，是一个一次性的协议，请求完服务器给响应，这次连接就断开了，http协议底层是tcp协议</li><li>http 0.9  只用于传输普通文本</li><li>http 1.0 支持长连接，连接成功后，隔多长时间不发送请求会自动断开</li></ul><h6 id="tcp三次握手："><a href="#tcp三次握手：" class="headerlink" title="tcp三次握手："></a>tcp三次握手：</h6><p>目的:建立连接</p><ul><li><p>​      第一次   客户端向服务器发送请求，服务器接收到这次请求   </p></li><li><p>​      第二次  客户端收到服务器的响应</p></li><li><p>​      第三次  客户端向服务器发送数据  ，示连接成功 </p></li><li></li></ul><h6 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h6><ul><li>1xx  :服务器连接成功，可以继续操作</li><li>2xx :响应成功，200</li><li>3xx :表示重定向 ，跳转地址</li><li>4xx ;页面路径找不到</li><li>5xx :服务器代码发生错误</li></ul><p>常规状态码：</p><p>200 成功；404 页面找不到；500 服务器代码发生错误</p><ol><li>出现404的情况;</li></ol><ul><li><p>页面的路径写错，导致页面找不到</p></li><li><p>tomcat没部署web项目</p></li><li><p>路径层次太深</p></li></ul><ol start="2"><li>出现500的情况：</li></ol><ul><li>查看控制台日志，找到具体的代码错误行，</li></ul><div class="hljs"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> void service(<span class="hljs-type">HttpServletRequest</span> req, <span class="hljs-type">HttpServletResponse</span> resp) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;        <span class="hljs-keyword">try</span> &#123;            int i=<span class="hljs-number">1</span>/<span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-type">Exception</span> e) &#123;            resp.sendError(<span class="hljs-number">500</span>, <span class="hljs-string">"除数不能为0"</span>);            e.printStackTrace();        &#125;    &#125;&#125;</code></pre></div><h6 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h6><ul><li>Location : 重定向，多少秒刷新页面</li><li>Content-Type : text/htm;charset=utf-8 设置响应的编码格式</li><li>Content-desponsition ： 用于文件下载</li><li>Conten-Encoding  ：设置响应的压缩类型</li><li>Date  :  用于记录服务器响应的时间</li></ul><div class="hljs"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> void service(<span class="hljs-type">HttpServletRequest</span> req, <span class="hljs-type">HttpServletResponse</span> resp) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;        resp.setHeader(<span class="hljs-string">"Connet-Type"</span>, <span class="hljs-string">"image/jpg"</span>);        java.io.<span class="hljs-type">InputStream</span> is=<span class="hljs-keyword">this</span>.getServletContext().getResourceAsStream(<span class="hljs-string">"WEB-INF/admin.jpg"</span>);        <span class="hljs-type">ServletOutputStream</span> outputStream=resp.getOutputStream();        byte[] bytes=<span class="hljs-keyword">new</span> byte[<span class="hljs-number">1024</span>];        int leng=<span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>((leng=is.read(bytes))!=<span class="hljs-number">-1</span>)&#123;            outputStream.write(bytes,<span class="hljs-number">0</span>,leng);        &#125;    &#125;&#125;</code></pre></div><h6 id="把一个图片响应写在浏览器"><a href="#把一个图片响应写在浏览器" class="headerlink" title="把一个图片响应写在浏览器"></a>把一个图片响应写在浏览器</h6><p>服务器存在一张图片 需要把图片直接读取到浏览器里 通过响应头来进行设置</p><p>分析: InputStream  outputSteam</p><ul><li>把图片放入到web-info下 </li><li>使用流来进行读写操作</li></ul><div class="hljs"><pre><code class="hljs reasonml">resp.set<span class="hljs-constructor">Header(<span class="hljs-string">"Connet-Type"</span>, <span class="hljs-string">"image/jpg"</span>)</span>;<span class="hljs-comment">//设置响应的格式是图片</span>InputStream is=this.get<span class="hljs-constructor">ServletContext()</span>.get<span class="hljs-constructor">ResourceAsStream(<span class="hljs-string">"WEB-INF/admin.jpg"</span>)</span>;<span class="hljs-comment">//把服务器上的图片转换为输入流</span>        ServletOutputStream outputStream=resp.get<span class="hljs-constructor">OutputStream()</span>;        <span class="hljs-comment">//读写操作</span>        byte<span class="hljs-literal">[]</span> <span class="hljs-built_in">bytes</span>=<span class="hljs-keyword">new</span> byte<span class="hljs-literal">[<span class="hljs-number">1024</span>]</span>;        <span class="hljs-built_in">int</span> leng=-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>((leng=is.read(<span class="hljs-built_in">bytes</span>))!=-<span class="hljs-number">1</span>)&#123;            outputStream.write(<span class="hljs-built_in">bytes</span>,<span class="hljs-number">0</span>,leng);                    &#125;</code></pre></div><h6 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h6><ul><li>界面需要写一个跳转标签，要传递参数为图片的名称</li><li>使用流进行读写操作</li><li>设置Content-Desposition  ，告诉浏览器是以下载的方式打开</li></ul><div class="hljs"><pre><code class="hljs xml">index.jsp设置：<span class="hljs-tag">&lt;<span class="hljs-name">%@</span> <span class="hljs-attr">page</span> <span class="hljs-attr">contentType</span>=<span class="hljs-string">"text/html;charset=UTF-8"</span> <span class="hljs-attr">language</span>=<span class="hljs-string">"java"</span> %&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>$Title$<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"userServlet?filename=admin.jpg"</span>&gt;</span>下载<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> void service(<span class="hljs-type">HttpServletRequest</span> req, <span class="hljs-type">HttpServletResponse</span> resp) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;       <span class="hljs-type">String</span> filename=req.getParameter(<span class="hljs-string">"filename"</span>);       resp.setHeader(<span class="hljs-string">"Content-Disposition"</span>, <span class="hljs-string">"attachment;filename="</span> +filename);        java.io.<span class="hljs-type">InputStream</span> is=<span class="hljs-keyword">this</span>.getServletContext().getResourceAsStream(<span class="hljs-string">"WEB-INF/admin.jpg"</span>);        <span class="hljs-type">ServletOutputStream</span> outputStream=resp.getOutputStream();        byte[] bytes=<span class="hljs-keyword">new</span> byte[<span class="hljs-number">1024</span>];        int leng=<span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>((leng=is.read(bytes))!=<span class="hljs-number">-1</span>)&#123;            outputStream.write(bytes,<span class="hljs-number">0</span>,leng);        &#125;    &#125;&#125;</code></pre></div><h6 id="响应头-1"><a href="#响应头-1" class="headerlink" title="响应头"></a>响应头</h6><p>常规的响应头：</p><ul><li>.Location =&gt;表示重定向  ==&gt;个多秒刷新页面</li><li>.Content-Type==&gt; text/htm;charset=utf-8设置响应的编码格式</li><li>Content-desposition  一般用于文件下载</li><li>Content-Encoding  表示设置响应的压缩类型</li><li>.Date 用于来记录服务器响应的时间</li></ul><p>设置响应头：</p><ul><li>resp.setHeader(s:”设置头的状态”，s1:”具体的值”)；  追加多个状态值，会覆盖</li><li>resp.addHeader(s:”设置头的状态”，s1:”具体的值”)；此方法可以追加多个状态值，不会覆盖</li></ul><h6 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h6><p>resp.getOutputStream() : </p><p>resp.getWriter() : 写普通文本</p><p>&lt;<em>web-inf下的资源 通过，路劲是直接获取不到 页面不要放入到web-inf下</em>&gt;</p><div class="hljs"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> UserServlet extends HttpServlet &#123;    @Override    protected <span class="hljs-type">void</span> service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    //响应的编码格式        resp.setContentType("text/html;charset=utf-8");        PrintWriter <span class="hljs-keyword">out</span>=resp.getWriter();        <span class="hljs-keyword">out</span>.<span class="hljs-keyword">write</span>("&lt;table border='1'&gt;");        <span class="hljs-keyword">out</span>.<span class="hljs-keyword">write</span>("&lt;tr&gt;");        <span class="hljs-keyword">out</span>.<span class="hljs-keyword">write</span>("&lt;td&gt;闪闪&lt;/td&gt;");        <span class="hljs-keyword">out</span>.<span class="hljs-keyword">write</span>("&lt;td&gt;Archar&lt;/td&gt;");        <span class="hljs-keyword">out</span>.<span class="hljs-keyword">write</span>("&lt;td&gt;哈哈哈&lt;/td&gt;");        <span class="hljs-keyword">out</span>.<span class="hljs-keyword">write</span>("&lt;/tr&gt;");        <span class="hljs-keyword">out</span>.<span class="hljs-keyword">write</span>("&lt;/table&gt;");        <span class="hljs-keyword">out</span>.flush();//关闭资源        <span class="hljs-keyword">out</span>.<span class="hljs-keyword">close</span>();    &#125;</code></pre></div><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">闪闪</td><td align="center">Archar</td><td align="center">哈哈哈</td></tr></tbody></table><h6 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h6><p>请求头是在发现数据的时候 请求的一些配置信息,这个信息不要设置 ,浏览器自己处理我们只需要获取</p><div class="hljs"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> void service(<span class="hljs-type">HttpServletRequest</span> req, <span class="hljs-type">HttpServletResponse</span> resp) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;        <span class="hljs-type">Enumeration</span>&lt;<span class="hljs-type">String</span>&gt; enumeration=req.getHeaderNames();        <span class="hljs-keyword">while</span>(enumeration.hasMoreElements())&#123;            <span class="hljs-type">String</span> key=enumeration.nextElement();            <span class="hljs-type">System</span>.out.println(key+<span class="hljs-string">"\t"</span>+req.getHeader(key));        &#125;    &#125;&#125;</code></pre></div><h6 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h6><ul><li><p>用于获取请求传递的参数</p></li><li><p>两个方法</p></li><li><p>据注意点： 所以的数据提交 都是根据name来获取其值所有的提交获取的都是其value值</p><div class="hljs"><pre><code class="hljs less"><span class="hljs-selector-tag">req</span><span class="hljs-selector-class">.getParameter</span>(<span class="hljs-attribute">s</span>:<span class="hljs-string">" "</span>);   <span class="hljs-comment">//获取单个</span><span class="hljs-selector-tag">req</span><span class="hljs-selector-class">.getParameterValues</span>();  <span class="hljs-comment">//获取一组数</span></code></pre></div></li></ul><div class="hljs"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> void service(<span class="hljs-type">HttpServletRequest</span> req, <span class="hljs-type">HttpServletResponse</span> resp) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;        req.setCharacterEncoding(<span class="hljs-string">"utf-8"</span>);        resp.setContentType(<span class="hljs-string">"text/html;charset=utf-8"</span>);        <span class="hljs-type">String</span> uname=req.getParameter(<span class="hljs-string">"uname"</span>);        <span class="hljs-type">String</span> pwd=req.getParameter(<span class="hljs-string">"pwd"</span>);        <span class="hljs-type">String</span> sex=req.getParameter(<span class="hljs-string">"sex"</span>);        <span class="hljs-type">String</span>[] str=req.getParameterValues(<span class="hljs-string">"sp"</span>);        <span class="hljs-keyword">if</span>(str !=<span class="hljs-literal">null</span> &amp;&amp; str.length&gt;<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">String</span> s:str)&#123;                <span class="hljs-type">System</span>.out.println(s);            &#125;        &#125;    &#125;&#125;</code></pre></div><h6 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h6><ul><li><p>上传的时候 from 表单 必须是post提交  </p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">enctype</span>=<span class="hljs-string">"multipart/form-data"</span></code></pre></div></li><li><p>页面</p><div class="hljs"><pre><code class="hljs routeros">&lt;form <span class="hljs-attribute">method</span>=<span class="hljs-string">"post"</span> <span class="hljs-attribute">enctype</span>=<span class="hljs-string">"multipart/form-data"</span>&gt;   &lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">"file"</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">"uanme"</span>&gt;   &lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">"提交"</span>&gt;</code></pre></div></li><li><p>添加jar包 并加入依赖</p><div class="hljs"><pre><code class="hljs angelscript">commons-fileupload<span class="hljs-number">-1.2</span><span class="hljs-number">.1</span>commons-io<span class="hljs-number">-1.4</span></code></pre></div></li></ul><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>web相关知识</title>
    <link href="/2020/06/02/web%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2020/06/02/web%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h5 id="web简介"><a href="#web简介" class="headerlink" title="web简介"></a>web简介</h5><ol><li><p>web开发: 前端开发 网站开发  java 中的web开发 不只有前端 还需要写后台</p></li><li><p>web资源 :也就网页上一些可以看见的就是web资源 比如图片 视频 标签 主要用于页面的</p></li><li><p>web的架构: c/s 架构  b/s架构</p></li></ol><h5 id="c-s架构-也就是客户端与服务器直接进行交互，"><a href="#c-s架构-也就是客户端与服务器直接进行交互，" class="headerlink" title="c/s架构 : 也就是客户端与服务器直接进行交互，"></a>c/s架构 : 也就是客户端与服务器直接进行交互，</h5><ul><li><p>优点:速度快 效率高,安全性比较高,不需要依赖与浏览器 但是需要较高的电脑配置</p></li><li><p>缺点:  必须在客户端安装相应的程序  维护升级比较麻烦</p></li></ul><h5 id="b-s架构-客户端向浏览器发送-gt-浏览器再向服务器发送请求"><a href="#b-s架构-客户端向浏览器发送-gt-浏览器再向服务器发送请求" class="headerlink" title="b/s架构: 客户端向浏览器发送 ==&gt; 浏览器再向服务器发送请求"></a>b/s架构: 客户端向浏览器发送 ==&gt; 浏览器再向服务器发送请求</h5><ul><li><p>优点:  维护升级方便  无缝进行替换</p></li><li><p>缺点: 速度慢依赖于浏览器 有些低版本浏览器动画效果是不能够显示</p></li><li><p>b/s架构的请求原理: </p><p>​      建议连接 ==&gt;索取微信号</p><p>​      聊天 =&gt;发送请求  </p><p>​      聊天  接收到请求  给其响应</p><p>​     请求连接关闭  </p><p>​     先发送请求 再有响应  请求与响应的是配套的</p></li></ul><h5 id="Web服务器的介绍"><a href="#Web服务器的介绍" class="headerlink" title="Web服务器的介绍"></a>Web服务器的介绍</h5><p> Web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，可以向浏览器等Web客户端提供文档，也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载。目前最主流的三个Web服务器是tomcat 、 weblogic 、IIS</p><p> url 地址: 统一资源定位符 ，也就是访问的路劲  只要是放在服务器上的  图片  页面 每一个都存在访问的路劲  </p><p>  url的组成部分：</p><p><a href="https://uland.taobao.com/sem/tbsearch?refpid=mm_26632258_3504122_32538762&amp;keyword=%E5%A5%B3%E8%A3%85&amp;clk1=c08fa79f9cd4b9e6c7727282760c1c1c&amp;upsid=c08fa79f9cd4b9e6c7727282760c1c1c" target="_blank" rel="noopener">https://uland.taobao.com/sem/tbsearch?refpid=mm_26632258_3504122_32538762&amp;keyword=%E5%A5%B3%E8%A3%85&amp;clk1=c08fa79f9cd4b9e6c7727282760c1c1c&amp;upsid=c08fa79f9cd4b9e6c7727282760c1c1c</a></p><ul><li>https  http 请求的协议</li><li>uland.taobao.com  域名或者是ip地址</li><li>sem/tbsearch 访问具体的资源的路劲</li><li>？后面都是以键值对的形式向服务器传递的参数   多个参数 &amp;进行拼接</li></ul><h4 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h4><ol><li><p>servlet 是运行在服务器的Java代码  主要用与做处理请求与响应  java web三大主组件之一</p></li><li><p>servlet的使用的步骤:</p></li></ol><ul><li>新建一个项目，配置tomcat服务器</li><li>在idea中添加servletjar</li><li>在web.xml配置servlet</li></ul><h4 id="servlet类的实现方式"><a href="#servlet类的实现方式" class="headerlink" title="servlet类的实现方式"></a>servlet类的实现方式</h4><div class="hljs"><pre><code class="hljs scala">最常用的方式：public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    public void service(<span class="hljs-type">ServletRequest</span> req, <span class="hljs-type">ServletResponse</span> res) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;        <span class="hljs-keyword">super</span>.service(req, res);    &#125;&#125;</code></pre></div><h4 id="servlet的生命周期"><a href="#servlet的生命周期" class="headerlink" title="servlet的生命周期"></a>servlet的生命周期</h4><ul><li><p>servlet是由tomcat容器创建 是在运行tomcat 的时候创建 所以用到 —servlet都需要添加tomcat的lib的jar</p></li><li><p>init() 表示servlet初始化 有且只执行一次  单例设置模式</p></li><li><p>service()方法 所以的请求与响应都会执行这个方法</p></li><li><p>destory() 方法 servlet销毁的执行这个方法  也就tomcat服务器关闭的时候执行</p></li><li><p>servlet 的生命周期是随着tomcat的开始而开始 结束而结束</p></li></ul><div class="hljs"><pre><code class="hljs applescript">&lt;load-<span class="hljs-keyword">on</span>-startup&gt;<span class="hljs-number">-1</span>&lt;/load-<span class="hljs-keyword">on</span>-startup&gt;</code></pre></div><p>设置这个表示 立即加载 是要是&gt;=0 就可以 可以为负数  默认值就是负数  最优先加载，值越小越优先加载</p><h5 id="servlet-访问路劲-通配符设置"><a href="#servlet-访问路劲-通配符设置" class="headerlink" title="servlet 访问路劲 通配符设置"></a>servlet 访问路劲 通配符设置</h5><ul><li><p>/*    表示所有的请求与响应都会执行这个servlet</p></li><li><p>/userservlet  表示 请求是userServlet的时候才会执行这个servlet</p></li><li><p>/admin/* 访问的路劲是admin文件下所有的文件都会执行这个servlet</p></li><li><p>*.do 表示.do结尾的请求路劲都会执行这个servlet</p></li></ul><h4 id="get-post区"><a href="#get-post区" class="headerlink" title="get post区"></a>get post区</h4><ul><li><p>get提交数据 浏览器会缓存数据</p></li><li><p>get提交数据有长度限制</p></li><li><p>get提交数据有大小限制</p></li><li><p>get一般用与文件下载</p></li></ul><p>  post：</p><ul><li><p>post提交数据 不会缓存数据到浏览器</p></li><li><p>post提交数据没有长度限制</p></li><li><p>post提交数据有加密 安全性高</p></li><li><p>post 一般用于表单提交</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
