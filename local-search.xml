<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>jdbc</title>
    <link href="/2020/05/31/jdbc/"/>
    <url>/2020/05/31/jdbc/</url>
    
    <content type="html"><![CDATA[<div class="hljs"><pre><code class="hljs subunit">title: JDBCdate: 2020<span class="hljs-string">-05</span><span class="hljs-string">-31</span> 22:30:00<span class="hljs-keyword">tags:</span>Database</code></pre></div><h4 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC:"></a>JDBC:</h4><p>官方定义的一套操作所有关系型数据库的规则（接口）；各个数据库产商去实现这个接口，提供数据库驱动</p><p>jar包，我们可以使用这套接口编程，真正执行的代码是驱动jar包中的实现类</p><h4 id="JDBC的操作做步骤"><a href="#JDBC的操作做步骤" class="headerlink" title="JDBC的操作做步骤"></a>JDBC的操作做步骤</h4><ol><li><p>新建一个名为lib的文件夹，用于存放jar包</p></li><li><p>下载驱动包：<a href="https://dev.mysql.com/downloads/connector/j/5.1.html" target="_blank" rel="noopener">https://dev.mysql.com/downloads/connector/j/5.1.html</a></p></li><li><p>添加项目依赖：选中lib目录下的jar包右击-&gt;Add as library-&gt;设置添加的驱动名字</p></li><li><p>验证添加依赖是否成功：file-&gt;Project Structure-&gt;Libraries,选中之后看右边是否出现刚才添加的jar包</p></li></ol><h4 id="JDBC开发流程"><a href="#JDBC开发流程" class="headerlink" title="JDBC开发流程"></a>JDBC开发流程</h4><ol><li><p>通过反射来加载驱动包</p></li><li><p>使用DeriverManger来获取连接对象</p></li><li><p>获取可以执行的SQL语句的对象statement</p></li><li><p>执行SQL语句</p></li><li><p>得到返回的结果</p></li><li><p>释放资源</p><div class="hljs"><pre><code class="hljs gradle">            <span class="hljs-keyword">import</span> com.mysql.jdbc.Driver;      <span class="hljs-keyword">import</span> java.sql.*;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> test &#123;          <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;              Connection con=<span class="hljs-keyword">null</span>;              Statement sta=<span class="hljs-keyword">null</span>;              ResultSet re=<span class="hljs-keyword">null</span>;              <span class="hljs-keyword">try</span> &#123;                  <span class="hljs-keyword">Class</span>.forName(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>);  <span class="hljs-comment">//通过反射来加载驱动</span>                  <span class="hljs-comment">//获取与数据库的连接对象con</span>                  con=DriverManager.getConnection(<span class="hljs-string">"jdbc:mysql://localhost:3306/student?characterEncoding=utf-8"</span>,<span class="hljs-string">"root"</span>,<span class="hljs-string">"123"</span>);                  sta=con.createStatement();<span class="hljs-comment">//通过连接对象得到SQL的执行对象sta</span>                   re=sta.executeQuery(<span class="hljs-string">"selet *from user"</span>);<span class="hljs-comment">//执行SQL语句，得到执行结果集</span>                  <span class="hljs-keyword">while</span>(re.<span class="hljs-keyword">next</span>())&#123;                           <span class="hljs-comment">//遍历结果集得到数据</span>                      <span class="hljs-keyword">int</span> uid=re.getInt(<span class="hljs-string">"uid"</span>);                      String uname=re.getString(<span class="hljs-string">"uname"</span>);                      String upwd=re.getString(<span class="hljs-string">"upwd"</span>);                      System.out.<span class="hljs-keyword">println</span>(uid+<span class="hljs-string">"\t"</span>+uname+<span class="hljs-string">"\t"</span>+upwd);                  &#125;              &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;                  e.printStackTrace();              &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                  e.printStackTrace();              &#125;<span class="hljs-keyword">finally</span> &#123;    <span class="hljs-comment">//关闭资源，先调用的先关闭，关闭前判断对象是否存在</span>                  <span class="hljs-keyword">try</span> &#123;                      <span class="hljs-keyword">if</span>(re !=<span class="hljs-keyword">null</span>)&#123;                          con.close();                      &#125;                      <span class="hljs-keyword">if</span>(sta !=<span class="hljs-keyword">null</span>)&#123;                          sta.close();                      &#125;                      <span class="hljs-keyword">if</span>(con !=<span class="hljs-keyword">null</span>)&#123;                          re.close();                      &#125;                  &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                      e.printStackTrace();                  &#125;              &#125;          &#125;      &#125;      <span class="hljs-comment">/*</span><span class="hljs-comment">Class.forName(“com.mysql.jdbc.Driver”); 通过反射来加载驱动 Driver ==&gt;驱动类</span><span class="hljs-comment">      DriverManager 驱动管理对象来获取连接对象 getConnection(“url”,“username”,“password”) =》返回值就是 Connection</span><span class="hljs-comment">      url==&gt;表示连接数据库的地址 jdbc:mysql://localhost:3306/数据库的库名?characterEncoding=utf-8 || jdbc:mysql:///day03_db 只支持本地连接</span><span class="hljs-comment">      jdbc: 表示主的协议==&gt;也就是使用jdbc来连接数据库</span><span class="hljs-comment">      mysql: 表示子协议==&gt;也及时使用mysql数据库</span><span class="hljs-comment">      localhost: 表示本机的ip地址</span><span class="hljs-comment">      3306 表示mysql数据库的端口号，端口号后是数据库的库ming</span><span class="hljs-comment">      ? 后都是表示设置的参数 characterEncoding=utf-8 ==&gt;设置其编码格式</span><span class="hljs-comment">      username:表示数据库的用户名</span><span class="hljs-comment">      password 表示数据库 密码</span><span class="hljs-comment">      conn.createStatement(); ==&gt;表示通过连接对象来获取执行sql 的对象Statement</span><span class="hljs-comment">      sta.executeQuery(sql) 发送sql语句，数据库返回一个结果集 ResultSet</span><span class="hljs-comment">      关闭资源(从下往上关闭)</span><span class="hljs-comment">      */</span></code></pre></div></li></ol><h4 id="Jdbc中用到的对象"><a href="#Jdbc中用到的对象" class="headerlink" title="Jdbc中用到的对象"></a>Jdbc中用到的对象</h4><h5 id="1-DriverManager对象：驱动管理对象"><a href="#1-DriverManager对象：驱动管理对象" class="headerlink" title="1.DriverManager对象：驱动管理对象"></a>1.DriverManager对象：驱动管理对象</h5><p>功能;</p><ul><li><p>注册驱动：告诉程序使用哪一个数据库驱动jar;  mysql5之后的驱动jar包可以省略注册驱动的步骤</p></li><li><p>获取数据库连接</p></li></ul><h5 id="2-Connection对象"><a href="#2-Connection对象" class="headerlink" title="2.Connection对象"></a>2.Connection对象</h5><div class="hljs"><pre><code>作用：完成客服端与数据库的交互常用的方法：</code></pre></div><p>​          1).获取执行sql对象</p><ul><li>createStatement()          //创建向数据库发送sql的statement对象                        </li></ul><ul><li><p>prepareStatement(sql)  //创建向数据库发送预编译sql的PrepareSatment对象</p></li><li><p>prepareCall(sql)     //创建执行存储过程的callableStatement对象</p><p>2).管理事务：</p></li><li><p>setAutoCommit(boolean autoCommit)  //设置事务自动提交</p></li><li><p>commit()  //提交事务</p></li><li><p>rollback()  //回滚事务</p><p>​    </p></li></ul><h5 id="3-Statement对象"><a href="#3-Statement对象" class="headerlink" title="3.Statement对象"></a>3.Statement对象</h5><p>   作用：用于向数据库发送sql语句，对数据库的增删改查都可以通过此对象发送sql语句完成</p><p>   常用的方法:</p><ul><li><p>executeQuery(String sql)        //执行DQL(SELECT)语句 </p></li><li><p>executeUpdate(String sql)  //执行DML语句（增删改），返回值是影响的行数(可以判断DML语句是否执行成功)</p></li><li><p>addBatch(String  sql)   //把多条sql语句放进同一个批处理中</p></li><li><p>executeBatch()      //向数据库发送一批sql语句执行     </p></li></ul><h5 id="4-ResultSet对象"><a href="#4-ResultSet对象" class="headerlink" title="4.ResultSet对象"></a>4.ResultSet对象</h5><p>作用：ResultSet对象代表sql语句的执行结果，当Statement执行executeQuery()时会返回一个ResultSet对象</p><p> ResultSet对象维护了⼀个数据⾏的游标，调⽤ResultSet.next()⽅法可以让游标指向具体的数据⾏，进⾏获取该⾏ 的数据</p><p>常用方法：</p><ul><li><p>getObject(String str)     //获取任意类型的数据</p></li><li><p>getString(String str)    //获取指定类型的数据</p></li></ul><p>//对结果集进行滚动查看的方法</p><ul><li><p>next()    //游标向下移动一行</p></li><li><p>Previous()</p></li><li><p>absolute(int row)</p></li><li><p>beforeFirst()</p></li><li><p>afterLast()</p></li></ul><h5 id="5-PreparedStatement对象"><a href="#5-PreparedStatement对象" class="headerlink" title="5.PreparedStatement对象"></a>5.PreparedStatement对象</h5><p>  PreparedStatement对象继承Statement对象</p><p>作用：</p><ul><li><p>Statement对象编译SQL语句时，如果SQL语句有变量，就需要使⽤分隔符来隔开，如果变量⾮常</p><p> 多，就会使SQL变得⾮常复杂，PreparedStatement可以使⽤占位符，简化sql的编写</p></li><li><p>Statement会频繁编译SQL。PreparedStatement可对SQL进⾏预编译，提⾼效率，预编译的<br> SQL存储在PreparedStatement对象中</p></li><li><p>PreparedStatement防⽌SQL注⼊。Statement通过分隔符’++’,编写永等式，可以不需要密码<br> 就进⼊数据库</p></li></ul><div class="hljs"><pre><code class="hljs routeros">  try &#123;        Class.forName(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>);       <span class="hljs-built_in"> Connection </span><span class="hljs-attribute">con</span>=DriverManager.getConnection("jdbc:mysql://localhost:3306/student?characterEncoding=utf-8","root","123");        String <span class="hljs-attribute">sql</span>=<span class="hljs-string">"insert into user(uid,uname,upwd)values(?,?,?)"</span>;        PreparedStatement <span class="hljs-attribute">ps</span>=con.prepareStatement(sql);        ps.setString(1,<span class="hljs-string">"1"</span>);    &#125; catch (ClassNotFoundException e) &#123;        e.printStackTrace();    &#125; catch (SQLException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre></div><p>解析:</p><ul><li>给其占位符来进行赋值  setInt(index,data) setString(index,data)<br>第一个参数表示设置索引 索引是从1开始<br>第二个参数表示 具体的赋值</li></ul><h4 id="Junit-测试"><a href="#Junit-测试" class="headerlink" title="Junit 测试"></a>Junit 测试</h4><p>   主要是用于测试代码<br>             使用步骤：</p><ul><li><p>.导包 添加依赖</p></li><li><p>编写一个测试方法(不是main)<br> 注意点:<br> 需要使用public void<br> 这个方法没有返回值<br> 这个方法没有参数</p></li><li><p>在方法加注解 @Test</p> <div class="hljs"><pre><code class="hljs aspectj"><span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        &#125;</code></pre></div></li></ul><ul><li>直接运行 绿色表示没有错误 红色表示产生了错误</li></ul><h4 id="Jdbc配置文件读取的封装"><a href="#Jdbc配置文件读取的封装" class="headerlink" title="Jdbc配置文件读取的封装****"></a>Jdbc配置文件读取的封装****</h4>  <div class="hljs"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-keyword">import</span> java.util.Properties;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcUtils</span> &#123;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JdbcUtils jdbcUtils;<span class="hljs-comment">//私有的属性，私有的构造</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">JdbcUtils</span><span class="hljs-params">()</span></span>&#123;              <span class="hljs-comment">//保证外部类不能实例化这个对象</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> synchronized JdbcUtils <span class="hljs-title">getJdbcUtils</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">//定义方法来实例化这个类</span>        <span class="hljs-keyword">if</span>(jdbcUtils==null)&#123;            jdbcUtils=<span class="hljs-keyword">new</span> JdbcUtils();        &#125;        <span class="hljs-keyword">return</span> jdbcUtils;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Properties properties;    <span class="hljs-keyword">static</span>&#123;        <span class="hljs-keyword">try</span> &#123;            properties=<span class="hljs-keyword">new</span> Properties();            InputStream fis=JdbcUtils.class.getResourceAsStream(<span class="hljs-string">"database.properties"</span>);<span class="hljs-comment">//通过类加载器来记载资源文件</span>            properties.load(fis);  <span class="hljs-comment">//当前文件 的内容已经加载到properties对象，调用properties对象就可以获得其内容</span>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">getValues</span><span class="hljs-params">(<span class="hljs-keyword">String</span> key)</span></span>&#123;  <span class="hljs-comment">//通过键值来获取，类似于hashMap对象</span>        <span class="hljs-keyword">return</span> properties.getProperty(key);    &#125;&#125;</code></pre></div><h4 id="jdbc的封装"><a href="#jdbc的封装" class="headerlink" title="jdbc的封装"></a><strong>jdbc的封装</strong></h4><p>1.加载驱动（只需要加载一次，写在静态代码块中)</p><p>2.获取连接对象写成一个方法 (三个参数写成常量)</p><p>3.增删改</p><p>4.查询</p><p>5.关闭资源</p><div class="hljs"><pre><code class="hljs reasonml">import com.mysql.jdbc.ResultSet;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException;public <span class="hljs-keyword">class</span> BaseDao &#123;    public  Connection get<span class="hljs-constructor">Connection()</span> &#123;  <span class="hljs-comment">//此方法用于连接对象</span>        Connection conn = null;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span>for<span class="hljs-constructor">Name(JdbcUtils.<span class="hljs-params">getJdbcUtils</span>()</span>.get<span class="hljs-constructor">Values(<span class="hljs-string">"jdbc.driver"</span>)</span>);            conn = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DriverManager</span>.</span></span>get<span class="hljs-constructor">Connection(JdbcUtils.<span class="hljs-params">getJdbcUtils</span>()</span>.get<span class="hljs-constructor">Values(<span class="hljs-string">"jdbc.url"</span>)</span>,                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JdbcUtils</span>.</span></span>get<span class="hljs-constructor">JdbcUtils()</span>.get<span class="hljs-constructor">Values(<span class="hljs-string">"jdbc.username"</span>)</span>,                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JdbcUtils</span>.</span></span>get<span class="hljs-constructor">JdbcUtils()</span>.get<span class="hljs-constructor">Values(<span class="hljs-string">"jdbc.password"</span>)</span>);        &#125; catch (ClassNotFoundException e) &#123;            e.print<span class="hljs-constructor">StackTrace()</span>;        &#125; catch (SQLException e) &#123;            e.print<span class="hljs-constructor">StackTrace()</span>;        &#125;        return conn;    &#125;    public <span class="hljs-built_in">int</span> update(String sql, Object<span class="hljs-literal">[]</span> objects) &#123;        <span class="hljs-built_in">int</span> num = -<span class="hljs-number">1</span>;        Connection con = null;        PreparedStatement ps = null;        <span class="hljs-keyword">try</span> &#123;            con = get<span class="hljs-constructor">Connection()</span>;<span class="hljs-comment">//获取连接对象</span>            ps = con.prepare<span class="hljs-constructor">Statement(<span class="hljs-params">sql</span>)</span>;<span class="hljs-comment">//执行得到的SQL对象</span>            <span class="hljs-keyword">if</span> (objects != null<span class="hljs-operator"> &amp;&amp; </span>objects.length &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//非空验证，判断是否需要拼接占位符</span>                for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; objects.length; i++) &#123;                    ps.set<span class="hljs-constructor">Object((<span class="hljs-params">i</span> + 1)</span>, objects<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>);<span class="hljs-comment">//给占位符一个个对应赋值</span>                &#125;            &#125;            num = ps.execute<span class="hljs-constructor">Update()</span>;        &#125; catch (SQLException e) &#123;            e.print<span class="hljs-constructor">StackTrace()</span>;        &#125; finally &#123;            close(null, ps, con);        &#125;        return num;    &#125;    public ResultSet select<span class="hljs-constructor">All(String <span class="hljs-params">sql</span>,Object[] <span class="hljs-params">objects</span>)</span>&#123;        ResultSet rs= null;        <span class="hljs-keyword">try</span> &#123;            Connection con = get<span class="hljs-constructor">Connection()</span>;            PreparedStatement  ps = con.prepare<span class="hljs-constructor">Statement(<span class="hljs-params">sql</span>)</span>;            <span class="hljs-keyword">if</span> (objects != null<span class="hljs-operator"> &amp;&amp; </span>objects.length &gt; <span class="hljs-number">0</span>) &#123;                for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; objects.length; i++) &#123;                    ps.set<span class="hljs-constructor">Object(<span class="hljs-params">i</span> + 1, <span class="hljs-params">objects</span>[<span class="hljs-params">i</span>])</span>;                &#125;            &#125;            ps.execute<span class="hljs-constructor">Query()</span>;        &#125;catch (SQLException e) &#123;            e.print<span class="hljs-constructor">StackTrace()</span>;        &#125;finally &#123;        &#125;        return rs;    &#125;    public void close(ResultSet rs,PreparedStatement ps,Connection conn)&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span>(rs!=null)&#123;                rs.close<span class="hljs-literal">()</span>;            &#125;            <span class="hljs-keyword">if</span>(ps!=null)&#123;                ps.close<span class="hljs-literal">()</span>;            &#125;            <span class="hljs-keyword">if</span>(conn!=null)&#123;                conn.close<span class="hljs-literal">()</span>;            &#125;        &#125; catch (SQLException e) &#123;            e.print<span class="hljs-constructor">StackTrace()</span>;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>多表查询和子查询</title>
    <link href="/2020/05/28/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%92%8C%E5%AD%90%E6%9F%A5%E8%AF%A2/"/>
    <url>/2020/05/28/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%92%8C%E5%AD%90%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h4 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h4><p>分析：1.查询的字段</p><p>​            2.查询所需要的条件</p><p>​            3.需要查询几张表</p><p>一.非等值查询</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>语法：select 列名<span class="hljs-number">1</span>，列名<span class="hljs-number">2</span> <span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span>，表<span class="hljs-number">2</span>此查询会造成大量数据冗余</code></pre></div><p>二.等值查询</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>语法：select 列名<span class="hljs-number">1</span>，列名<span class="hljs-number">2</span> <span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span>，表<span class="hljs-number">2</span>  加上约束条件</code></pre></div><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><p>一.内连接查询</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200528201813919.png" srcset="/img/loading.gif" style="zoom: 80%;" /> result表</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200528201950816.png" srcset="/img/loading.gif" style="zoom:80%;" />subject表</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200528202206131.png" srcset="/img/loading.gif" style="zoom:80%;" />student表</p><p>匹配规则：取的是两表的交集<br>例：查询参加了考试的同学信息（学号、学生姓名、科目编号、分数）</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s.StudentNo,s.StudentName,r.SubjectNo,r.StudentResult     <span class="hljs-keyword">FROM</span> student s,<span class="hljs-keyword">result</span> r <span class="hljs-keyword">WHERE</span> s.StudentNo=r.StudentNo          <span class="hljs-keyword">SELECT</span> s.StudentNo,s.StudentName,r.SubjectNo,r.StudentResult     <span class="hljs-keyword">FROM</span> student s <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">result</span> r <span class="hljs-keyword">ON</span> s.StudentNo=r.StudentNo</code></pre></div><ol><li><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200528202628613.png" srcset="/img/loading.gif" style="zoom:80%;" /></li></ol><p>二.左外连接</p><p>匹配的规则：以左表为基准，右表一一匹配，匹配不上的，左表依赖显示，右表设置为null<br>例：查询出所有同学，不考试的也查出来</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s.StudentNo,s.StudentName,r.StudentResult,r.SubjectNo   <span class="hljs-keyword">FROM</span> student s <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">result</span> r <span class="hljs-keyword">ON</span> s.StudentNo=r.StudentNo</code></pre></div> <!--student表为左表，result表为右表--><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200528203551326.png" srcset="/img/loading.gif" style="zoom: 50%;" /><p>三.右外连接</p><p>匹配的规则：以右表为基准，左表一一匹配，匹配不上的，右表依赖显示，左表设置为null<br>例：查一下缺考的同学</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s.StudentNo,s.StudentName,r.SubjectNo,r.StudentResult    <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span> r <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> student s <span class="hljs-keyword">ON</span> r.StudentNo=s.StudentNo        <span class="hljs-keyword">WHERE</span> r.StudentResult <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span></code></pre></div><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200528211533116.png" srcset="/img/loading.gif" style="zoom:80%;" /><p>四.子查询</p><p>定义 :一个完整的查询语句 嵌套另一个完整的查询语句</p><ol><li><p>第一种形式 把一个子查询的结果当做另一个子查询的条件来使用</p><p>例：查询参加了考试的同学信息（学号、学生姓名、科目名、分数）</p></li></ol><div class="hljs"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> s.studentNo,s.studentName,sub.SubjectName,r.studentResult <span class="hljs-keyword">FROM</span> student s <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> result r <span class="hljs-keyword">ON</span> s.studentNo = r.studentNo <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-symbol">`subject`</span> sub <span class="hljs-keyword">ON</span> r.subjectNo=sub.SubjectNo</code></pre></div><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200528213038051.png" srcset="/img/loading.gif" style="zoom:80%;" /><p>子查询与连接查询嵌套:</p><p>例：查询《数据库结构-1》的所有考试结果，并按成绩由高到低排列</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s.StudentNo,s.StudentName,r.StudentResult,sub.subjectName <span class="hljs-keyword">FROM</span> student s <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">result</span> r <span class="hljs-keyword">ON</span> s.StudentNo=r.StudentNo<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-string">`subject`</span> sub <span class="hljs-keyword">ON</span> sub.subjectNo=r.SubjectNo <span class="hljs-keyword">WHERE</span> sub.subjectName=<span class="hljs-string">"数据库结构-1"</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> r.StudentResult <span class="hljs-keyword">DESC</span></code></pre></div><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200528212057106.png" srcset="/img/loading.gif" style="zoom:80%;" /><p>2.第二种子查询的方式:</p><p>   把子查询查询出的结果当成列来进行显示:</p><p>例：查询课程为《高等数学-2》且分数不小于80分的学生的学号和姓名</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s.StudentNo,s.StudentName <span class="hljs-keyword">FROM</span> student s <span class="hljs-keyword">WHERE</span> s.StudentNo<span class="hljs-keyword">IN</span>(<span class="hljs-keyword">SELECT</span> r.StudentNo <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span> r <span class="hljs-keyword">WHERE</span> r.StudentResult&gt;=<span class="hljs-number">80</span><span class="hljs-keyword">AND</span> r.SubjectNo <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> sub.SubjectNo <span class="hljs-keyword">FROM</span> <span class="hljs-string">`subject`</span> sub <span class="hljs-keyword">WHERE</span> sub.SubjectName=<span class="hljs-string">"高等数学-2"</span>));</code></pre></div> <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200528213818971.png" srcset="/img/loading.gif" style="zoom: 80%;"                      />   <p>总结一下：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">/* 子查询 */</span> <span class="hljs-comment">------------------</span>    - 子查询需用括号包裹。<span class="hljs-comment">-- from型</span>    from后要求是一个表，必须给子查询结果取个别名。    - 简化每个查询内的条件。    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。    - 子查询返回一个表，表型子查询。    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> subfrom <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>&gt;<span class="hljs-number">1</span>;    <span class="hljs-comment">-- where型</span>    - 子查询返回一个值，标量子查询。    - 不需要给子查询取别名。    - where子查询内的表，不能直接用以更新。    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb <span class="hljs-keyword">where</span> money = (<span class="hljs-keyword">select</span> <span class="hljs-keyword">max</span>(money) <span class="hljs-keyword">from</span> tb)    <span class="hljs-comment">-- 列子查询</span>        如果子查询结果返回的是一列。        使用 <span class="hljs-keyword">in</span> 或 <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> 完成查询        <span class="hljs-keyword">exists</span> 和 <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> 条件            如果子查询返回数据，则返回<span class="hljs-number">1</span>或<span class="hljs-number">0</span>。常用于判断条件。            <span class="hljs-keyword">select</span> column1 <span class="hljs-keyword">from</span> t1 <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t2);<span class="hljs-comment">-- 行子查询</span>        查询条件是一个行。        <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t1 <span class="hljs-keyword">where</span> (<span class="hljs-keyword">id</span>, gender) <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>, gender <span class="hljs-keyword">from</span> t2);        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。        <span class="hljs-comment">-- 特殊运算符</span>    != all()    相当于 not in    = some()    相当于 in。any 是 some 的别名    != some()   不等同于 not in，不等于其中某一个。    all, some 可以配合其他运算符一起使用。</code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql</title>
    <link href="/2020/05/28/mysql/"/>
    <url>/2020/05/28/mysql/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a><strong>mysql</strong></h1><h5 id="一-创建数据库"><a href="#一-创建数据库" class="headerlink" title="一.创建数据库"></a>一.创建数据库</h5><ol><li>创建一个数据库 </li></ol><p>​          语法:  create  database  数据库的库名</p><p>   2.在创建数据库的时候给其设置编码格式 </p><p>​           语法：create  database  数据库的库名  character  set  utf8</p><p>   3.在创建数据库的时候 判断数据库 是否存在</p><p>​          语法：create database  if not exists   数据库名</p><p>   4.创建并查看数据库的结构</p><p>​         语法：show  create  database  数据库的库名</p><p>   5.修改数据库的编码格式</p><p>​         语法： alter  database  数据库的库名  character  set gbk</p><p>   6.切换到具体的某一个数据库</p><p>​         语法：use  数据库的库名</p><p>   7.查看所有的数据库</p><p>​         语法： show  databases</p><p>​    8.删库跑路</p><p>​       语法： drop  database   数据库的库名</p><h5 id="二-数据类型"><a href="#二-数据类型" class="headerlink" title="二.数据类型"></a>二.数据类型</h5><ol><li><p>int  整形 </p></li><li><p>double 小数</p></li><li><p>char  字符串  不可以变的字符串  不管数据的多少 都会占 设置的长度  不够的使用””来代替 一般用于设置固定长度的字符型(性别 男 或者是女)</p></li><li><p>varchar ==&gt;可变 的字符串  根据数据来设置其长度 </p></li><li><p>date <!--年月日--></p></li><li><p>datetime  年月日 时分秒</p></li></ol><h5 id="三-创建表"><a href="#三-创建表" class="headerlink" title="三.创建表"></a>三.创建表</h5><ol><li><p>语法:</p><p>   create  table  表名(</p><p>​       列名1  数据类型(长度),</p><p>​       列名2  数据类型(长度),</p><p>​       列名3  数据类型(长度）</p><p>);</p><!--注意 一定要切入到对应的数据库  use  数据库的名字--></li></ol><ol start="2"><li>查看表创建的结构:</li></ol><p>​           语法： desc  表名</p><ol start="3"><li>修改表的名字</li></ol><p>​           语法：alter  table  表名  rename  to  新的表名</p><ol start="4"><li>查看当前库中所有表</li></ol><p>​          语法：show  tables </p><ol start="5"><li>新增加一列</li></ol><p>​          语法：alter  table  表名  add  列名  数据类型(长度);</p><ol start="6"><li>只修改数据类型 </li></ol><p>​           语法：alter  table  表名  modify  列名  数据类型(长度)</p><ol start="7"><li>修改列名</li></ol><p>​           语法：alter  table  表名  change  原列名  新的列名 数据类型(长度)</p><h5 id="四-DML语句"><a href="#四-DML语句" class="headerlink" title="四.DML语句"></a>四.DML语句</h5><h5 id="1-插入语句"><a href="#1-插入语句" class="headerlink" title="1.插入语句"></a>1.插入语句</h5><ul><li><p>插入一条数据:</p><p>​         语法： insert into 表名 (sid,sname,spwd,createTime)values(值1,值2，值3，值4)</p></li><li><p>不指定列名 按照顺序来进行插入(不常用 容易出现错误)</p><p>​         语法：  insert  into  表名  values(插入的值1,插入的值2);</p><p>​         注意: 必须所以的列都要插入值</p></li></ul><ul><li>插入多条数据</li></ul><p>​          语法:  insert  into 表名  value(第一组值),(第二组值)</p><p>​           注意事项 ：</p><p>​            列名必须是表名存在的  </p><p>​             列名的类型与插入值的类型要对应</p><p>​             插入的是事件类型 一定要加上单引号</p><h5 id="2-修改"><a href="#2-修改" class="headerlink" title="2.修改"></a>2.修改</h5><ul><li>修改一个列</li></ul><p>​            语法： update 表名  set  列名=1数据  where 条件</p><ul><li><p>修改多个列</p><div class="hljs"><pre><code>语法：update  表名  set 列名=数据1,列名2=数据2  where  条件</code></pre></div></li><li><p>修改表中所有的数据</p><p>​             语法： update  表名  set  列名=数据1, 列名2=数据2  </p></li></ul><h5 id="3-删除"><a href="#3-删除" class="headerlink" title="3,.删除"></a>3,.删除</h5><p>​         语法：delete  from  表名  where  条件</p><p>​          删除所有的数据 ：delete  from  表名        一定要慎用</p><h5 id="4-查询语句"><a href="#4-查询语句" class="headerlink" title="4.查询语句"></a>4.查询语句</h5><ul><li><p>查询语句的关键子是select   from  </p><p> *表示查询所有的数据,也可以根据具体的字段来查询指定的</p></li><li><p>去重复  DISTINCT </p></li><li><p>设置别名 关键字是 as  as可以给表 设置 也可以列设置  as可以省略</p></li><li><p>根据条件来进行查询</p><p>关键字:where  or 或者 and  并且  between and  在什么范围之类 </p></li><li><p>模糊查询 like  % 匹配所以  _匹配一个字符</p></li><li><p>is  not  null  ，is  null   这里null 并不是” ”，is null是指没有插入数据</p></li><li><p>分页查询的关键字 limit 参数1， 参数2  参数1表示数据索引  参数2表示页量</p><p>索引：（当前页-1）*页量</p></li><li><p>升序 与降序  order by      asc 升   desc  降</p></li><li><p>聚合函数   count()   sum()   max()  min()    avg()</p></li><li><p>分组 关键字 group  by </p></li><li><p>过滤使用的是 having </p></li><li><p>having 过滤 与where的区别  一个是分组前where  having是在分组后</p></li><li><p>查询语句不能随便调换位置 </p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
